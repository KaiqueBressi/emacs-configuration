require 'logger'
require 'json'
require 'concurrent'
require 'httparty'

class Camunda
  include HTTParty

  logger ::Logger.new($stdout)

  base_uri 'https://api.stg.creditas.io/v0/journey-v2'
  headers 'Authorization' => "Bearer #{ENV.fetch('TOKEN')}", 'Content-Type' => 'application/json'
end


def modify_variable_body(operation_profile)
  JSON.dump(
    {
      "modifications" => {
        "operation_profile" => {
          "value" => operation_profile,
          "type" => "String"
        }
      }
    }
  )
end

DMN_KEY = "ProfileRatingTable"


pool = Concurrent::FixedThreadPool.new(128, fallback_policy: :caller_runs)

process_instances = Concurrent::Promises.future { Camunda.post("/engine-rest/process-instance", body: JSON.dump({"processDefinitionKey" => "FluxoHome"})) }.value!

File.open('errors.txt', 'w') do |f|
  errors = []

  all_variables_requests = process_instances.each_with_object({}) do |process_instance, result|
    process_instance_id = process_instance.fetch('id')

    result[process_instance_id] = Concurrent::Promises.future_on(pool) do
      response = Camunda.get("/engine-rest/process-instance/#{process_instance_id}/variables")

      unless response.code == 200
        errors << process_instance_id

        f.write("Erro no GET de Variables!: #{process_instance_id} + #{response.message}\n")
      end

      response
    end
  end

  all_variables_requests.values.map(&:wait!)

  process_instances_to_update = all_variables_requests.select do |process_instance_id, variable_promise|
    !errors.include?(process_instance_id) && variable_promise.value['operation_profile']
  end

  all_operation_profile_requests = process_instances_to_update.each_with_object({}) do |(process_instance_id, variable_promise), result|
    result[process_instance_id] = Concurrent::Promises.future_on(pool) do
      dmn_variables = { variables: variable_promise.value.parsed_response }
      response = Camunda.post("/engine-rest/decision-definition/key/#{DMN_KEY}/evaluate", body: JSON.dump(dmn_variables))

      unless response.code == 200
        errors << process_instance_id

        f.write("Erro no GET de Variables!: #{process_instance_id} + #{response.message}\n")
      end

      response
    end
  end

  all_operation_profile_requests.values.map(&:wait!)

  process_instances_to_update = all_operation_profile_requests.select do |process_instance_id, operation_profile_promise|
    !errors.include?(process_instance_id)
  end

  puts "Total de Process Instances: #{process_instances.count}"
  puts "Total de Process Instances para Atualizar: " + process_instances_to_update.count.to_s

  puts "Tem certeza que deseja rodar a migração? Yes/No"

  yesorno = gets.chomp
  exit unless yesorno == "yes"

  all_update_requests = process_instances_to_update.map do |process_instance_id, operation_profile_promise|
    operation_profile = operation_profile_promise.value[0].values[0]['value']

    Concurrent::Promises.future_on(pool) do
      response = Camunda.post("/engine-rest/process-instance/#{process_instance_id}/variables", body: modify_variable_body(operation_profile))

      f.write("Erro no POST de Variables!: #{process_instance_id} + #{response.message}\n") unless response.code == 204
    end
  end

  all_update_requests.map(&:wait!)
end
