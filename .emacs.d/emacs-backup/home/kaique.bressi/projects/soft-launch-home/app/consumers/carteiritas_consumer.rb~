# frozen_string_literal: true

require 'newrelic_rpm'
require 'new_relic/agent/distributed_tracing'
require 'avro_turf/messaging'

class JourneyConsumer < Racecar::Consumer
  include NewRelic::Agent::Instrumentation::ControllerInstrumentation
  include NewRelic::Agent::DistributedTracing

  subscribes_to 'journey-orchestration'

  ACTIVITY_ASSIGNED_EVENTS = ['activity-assigned', 'activity-autoassigned'].freeze

  def initialize
    @avro_decoder = ::AvroTurf::Messaging.new(
      registry_url: ENV.fetch('AVRO_SCHEMA_REGISTRY_URL')
    )
  end

  def process(message)
    parsed_message = @avro_decoder.decode(message.value)
    accept_new_relic_payload(parsed_message)
    dispatch_to_worker(parsed_message)
  rescue StandardError => ex
    Racecar.logger.error "Error while handling message: #{ex}"
    NewRelic::Agent.notice_error(ex)
  end
  add_transaction_tracer :process

  private

  def dispatch_to_worker(message)
    if ACTIVITY_ASSIGNED_EVENTS.include?(message.fetch('event'))
      JourneyActivityAssignedWorker.perform_async(message)
      return
    end

    Racecar.logger.info "Ignoring message #{message}"
  end

  def accept_new_relic_payload(message)
    new_relic_payload = message.fetch('new_relic_distributed_tracing')
    return unless new_relic_payload

    NewRelic::Agent::DistributedTracing.accept_distributed_trace_payload(
      new_relic_payload
    )
  end
end
